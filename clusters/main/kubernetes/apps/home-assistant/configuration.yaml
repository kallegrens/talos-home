# Configure a default setup of Home Assistant (frontend, api, etc)
default_config:
# Text to speech
tts:
  - platform: google_translate
group: !include groups.yaml
automation: !include automations.yaml
script: !include scripts.yaml
scene: !include scenes.yaml
recorder:
  purge_keep_days: 365
  commit_interval: 3
  db_url: "postgresql://home-assistant:PLACEHOLDERPASSWORD@home-assistant-cnpg-main-rw:5432/home-assistant?client_encoding=utf8"

# ---------------------------------------------------------------------------
# Manual toggles
# ---------------------------------------------------------------------------
input_boolean:
  solar_panels_snow_covered:
    name: Solar panels snow covered
    icon: mdi:snowflake-alert
  emhass_send_tail_prices:
    name: EMHASS send tail prices (3rd day)
    icon: mdi:calendar-arrow-right
    initial: false

input_number:
  emhass_idle_streak:
    name: EMHASS consecutive idle count
    icon: mdi:counter
    min: 0
    max: 100
    step: 1
    initial: 0
    mode: box

# ---------------------------------------------------------------------------
# EMHASS REST commands
# ---------------------------------------------------------------------------
rest_command:
  emhass_mpc_optim:
    url: "http://emhass.emhass.svc.cluster.local:5000/action/naive-mpc-optim"
    method: POST
    content_type: "application/json"
    timeout: 30
    payload: >-
      {%- set curr_soc = states('sensor.goodwe_battery_state_of_charge') | float(0) / 100 -%}
      {%- set soc_final_target = 0.05 -%}
      {%- set snow = is_state('input_boolean.solar_panels_snow_covered', 'on') -%}
      {%- set bms_no_discharge = is_state('binary_sensor.bms_discharge_disabled', 'on') -%}
      {%- set bms_no_charge = is_state('binary_sensor.bms_charge_disabled', 'on') -%}
      {%- set max_horizon_slots = 288 -%}
      {%- set slots_per_day = 96 -%}
      {%- set slot_minutes = 15 -%}
      {%- set all_buy = state_attr('sensor.emhass_buy_price_forecast', 'prices') | default({}, true) -%}
      {%- set all_sell = state_attr('sensor.emhass_sell_price_forecast', 'prices') | default({}, true) -%}
      {%- set t = now() -%}
      {%- set slot_epoch = as_timestamp(t.replace(minute=(t.minute // slot_minutes) * slot_minutes, second=0, microsecond=0)) -%}
      {%- set buy_dict = namespace(d={}) -%}
      {%- set sell_dict = namespace(d={}) -%}
      {%- for ts_key, price in all_buy.items() if as_timestamp(ts_key) >= slot_epoch -%}
        {%- set buy_dict.d = dict(buy_dict.d, **{ts_key: price}) -%}
      {%- endfor -%}
      {%- for ts_key, price in all_sell.items() if as_timestamp(ts_key) >= slot_epoch -%}
        {%- set sell_dict.d = dict(sell_dict.d, **{ts_key: price}) -%}
      {%- endfor -%}
      {%- set horizon = [sell_dict.d | length, max_horizon_slots] | min -%}
      {
        "soc_init": {{ curr_soc }},
        "soc_final": {{ soc_final_target }},
        "prediction_horizon": {{ horizon }},
        "operating_hours_of_each_deferrable_load": [0, 0],
        "load_cost_forecast": {{ buy_dict.d | tojson }},
        "prod_price_forecast": {{ sell_dict.d | tojson }},
        "battery_minimum_state_of_charge": {{ curr_soc if bms_no_discharge else 0.05 }},
        "battery_maximum_state_of_charge": {{ curr_soc if bms_no_charge else 1.0 }}
        {%- if snow -%}
          {%- set ypv = state_attr('sensor.pv_daily_profile', 'yesterday') | default([], true) -%}
          {%- set slot_idx = (now().hour * (slots_per_day // 24)) + (now().minute // slot_minutes) -%}
          {%- set ns = namespace(pv=[]) -%}
          {%- for i in range(horizon) -%}
            {%- set idx = (slot_idx + i) % slots_per_day -%}
            {%- if idx < ypv | length -%}
              {%- set ns.pv = ns.pv + [ypv[idx] | float(0)] -%}
            {%- else -%}
              {%- set ns.pv = ns.pv + [0] -%}
            {%- endif -%}
          {%- endfor -%}
          ,"pv_power_forecast": {{ ns.pv | tojson }}
        {%- endif %}
      }

  emhass_weather_cache:
    url: "http://emhass.emhass.svc.cluster.local:5000/action/weather-forecast-cache"
    method: POST
    content_type: "application/json"
    payload: "{}"
    timeout: 60

# ---------------------------------------------------------------------------
# Template sensors
# ---------------------------------------------------------------------------
template:
  - trigger:
      - trigger: time
        at: "13:05:00"
      - trigger: event
        event_type: tibber_cache_refresh
      - trigger: template
        value_template: >-
          {{ state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'tomorrow_valid') == true }}
    action:
      - action: tibber.get_prices
        data:
          start: "{{ today_at('00:00') }}"
          end: "{{ today_at('00:00') + timedelta(days=2) }}"
        response_variable: tibber_result
    sensor:
      - name: "Tibber Cached Prices"
        unique_id: tibber_cached_prices
        state: >-
          {{ tibber_result.prices['Lavendelgången 3'] | length }}
        unit_of_measurement: "entries"
        attributes:
          prices: >-
            {{ tibber_result.prices['Lavendelgången 3'] }}
          last_fetch: "{{ now().isoformat() }}"

  # Pre-computed buy/sell price forecasts for EMHASS.
  # Merges Tibber (incl. VAT+markup) with Nordpool (fallback), adds
  # energiskatt+nätavgift for buy, grid compensation for sell, and
  # appends a tail-extension day for horizon padding.
  # Triggers whenever Tibber cache or Nordpool data changes.
  - trigger:
      - trigger: state
        entity_id: sensor.tibber_cached_prices
      - trigger: state
        entity_id: sensor.nordpool_kwh_se3_sek_3_10_0
      - trigger: state
        entity_id: input_boolean.emhass_send_tail_prices
      - trigger: time_pattern
        minutes: "/15"
    sensor:
      - name: "EMHASS Buy Price Forecast"
        unique_id: emhass_buy_price_forecast
        unit_of_measurement: "SEK/kWh"
        device_class: monetary
        state_class: measurement
        state: >-
          {%- set slot_minutes = 15 -%}
          {%- set t = now() -%}
          {%- set slot_key = t.replace(minute=(t.minute // slot_minutes) * slot_minutes, second=0, microsecond=0).strftime('%Y-%m-%d %H:%M:%S%z') -%}
          {%- set slot_key = slot_key[:-2] ~ ':' ~ slot_key[-2:] -%}
          {%- set prices = this.attributes.get('prices', {}) -%}
          {{ prices.get(slot_key, 'unknown') }}
        attributes:
          prices: >-
            {%- set energiskatt_och_natavgift = 0.607 -%}
            {%- set tibber_vat_multiplier = 1.25 -%}
            {%- set tibber_fixed_markup = 0.116 -%}
            {%- set seconds_per_day = 86400 -%}
            {%- set tibber_prices = state_attr('sensor.tibber_cached_prices', 'prices') | default([], true) -%}
            {%- set np_today = state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'raw_today') | default([], true) -%}
            {%- set np_tomorrow = state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'raw_tomorrow') | default([], true) -%}
            {%- set np_all = np_today + np_tomorrow -%}
            {%- set tibber_by_ts = namespace(d={}) -%}
            {%- for p in tibber_prices if p is mapping -%}
              {%- set ts_key = as_timestamp(p.start_time) | int | string -%}
              {%- set tibber_by_ts.d = dict(tibber_by_ts.d, **{ts_key: p.price}) -%}
            {%- endfor -%}
            {%- set buy_dict = namespace(d={}) -%}
            {%- for p in np_all if p is mapping -%}
              {%- set ts_key = as_timestamp(p.start) | int | string -%}
              {%- set tibber_price = tibber_by_ts.d.get(ts_key, none) -%}
              {%- if tibber_price is not none -%}
                {%- set buy_price = tibber_price -%}
              {%- else -%}
                {%- set buy_price = (p.value * tibber_vat_multiplier + tibber_fixed_markup) | round(4) -%}
              {%- endif -%}
              {%- set buy_dict.d = dict(buy_dict.d, **{p.start | string: (buy_price + energiskatt_och_natavgift) | round(4)}) -%}
            {%- endfor -%}
            {%- if is_state('input_boolean.emhass_send_tail_prices', 'on') -%}
              {%- set tail_src = np_tomorrow if np_tomorrow | length > 0 else np_today -%}
              {%- for p in tail_src if p is mapping -%}
                {%- set shifted_key = (as_timestamp(p.start) + seconds_per_day) | timestamp_local -%}
                {%- set buy_price = (p.value * tibber_vat_multiplier + tibber_fixed_markup + energiskatt_och_natavgift) | round(4) -%}
                {%- set buy_dict.d = dict(buy_dict.d, **{shifted_key: buy_price}) -%}
              {%- endfor -%}
            {%- endif -%}
            {{ buy_dict.d }}
          last_updated: "{{ now().isoformat() }}"

      - name: "EMHASS Sell Price Forecast"
        unique_id: emhass_sell_price_forecast
        unit_of_measurement: "SEK/kWh"
        device_class: monetary
        state_class: measurement
        state: >-
          {%- set slot_minutes = 15 -%}
          {%- set t = now() -%}
          {%- set slot_key = t.replace(minute=(t.minute // slot_minutes) * slot_minutes, second=0, microsecond=0).strftime('%Y-%m-%d %H:%M:%S%z') -%}
          {%- set slot_key = slot_key[:-2] ~ ':' ~ slot_key[-2:] -%}
          {%- set prices = this.attributes.get('prices', {}) -%}
          {{ prices.get(slot_key, 'unknown') }}
        attributes:
          prices: >-
            {%- set grid_compensation = 0.047 -%}
            {%- set seconds_per_day = 86400 -%}
            {%- set np_today = state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'raw_today') | default([], true) -%}
            {%- set np_tomorrow = state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'raw_tomorrow') | default([], true) -%}
            {%- set np_all = np_today + np_tomorrow -%}
            {%- set sell_dict = namespace(d={}) -%}
            {%- for p in np_all if p is mapping -%}
              {%- set sell_dict.d = dict(sell_dict.d, **{p.start | string: (p.value + grid_compensation) | round(4)}) -%}
            {%- endfor -%}
            {%- if is_state('input_boolean.emhass_send_tail_prices', 'on') -%}
              {%- set tail_src = np_tomorrow if np_tomorrow | length > 0 else np_today -%}
              {%- for p in tail_src if p is mapping -%}
                {%- set shifted_key = (as_timestamp(p.start) + seconds_per_day) | timestamp_local -%}
                {%- set sell_price = (p.value + grid_compensation) | round(4) -%}
                {%- set sell_dict.d = dict(sell_dict.d, **{shifted_key: sell_price}) -%}
              {%- endfor -%}
            {%- endif -%}
            {{ sell_dict.d }}
          last_updated: "{{ now().isoformat() }}"

  # Yesterday's PV profile — 96 readings (one per 15-min slot).
  # Used by the MPC snow override: if panels are snow-covered, feed
  # yesterday's actual production instead of the clear-sky forecast.
  # Rolls over at the first sample after midnight each day.
  - trigger:
      - trigger: time_pattern
        minutes: "/15"
    sensor:
      - name: "PV Daily Profile"
        unique_id: pv_daily_profile
        state: >-
          {{ state_attr('sensor.pv_daily_profile', 'yesterday') | default([], true) | length }} entries
        attributes:
          today: >-
            {% set stored_date = this.attributes.get('date', '') %}
            {% set today_str = now().strftime('%Y-%m-%d') %}
            {% if stored_date != today_str %}
              {{ [states('sensor.goodwe_pv_power') | float(0)] }}
            {% else %}
              {{ this.attributes.get('today', []) + [states('sensor.goodwe_pv_power') | float(0)] }}
            {% endif %}
          yesterday: >-
            {% set stored_date = this.attributes.get('date', '') %}
            {% set today_str = now().strftime('%Y-%m-%d') %}
            {% if stored_date != today_str %}
              {{ this.attributes.get('today', []) }}
            {% else %}
              {{ this.attributes.get('yesterday', []) }}
            {% endif %}
          date: "{{ now().strftime('%Y-%m-%d') }}"

  # Grid power with flipped sign convention: positive = importing, negative = exporting.
  # Replaces the Tibber Pulse for real-time grid power in the Energy Dashboard.
  - sensor:
      - name: "Grid Power"
        unique_id: grid_power
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >-
          {{ -(states('sensor.goodwe_meter_active_power_total') | float(0)) }}

  # Snow detector: fires when forecast > min_forecast_w but actual < snow_threshold (5%).
  # An automation latches input_boolean.solar_panels_snow_covered ON
  # when this turns on. A separate automation clears the boolean when
  # actual PV recovers (> 50% of forecast for 30 min).
  - binary_sensor:
      - name: Solar Snow Detected
        unique_id: solar_snow_detected
        device_class: problem
        state: >-
          {% set min_forecast_w = 100 %}
          {% set snow_threshold = 0.05 %}
          {% set forecast = states('sensor.p_pv_forecast') | float(0) %}
          {% set actual = states('sensor.goodwe_pv_power') | float(0) %}
          {{ forecast > min_forecast_w and actual < forecast * snow_threshold }}
        icon: >-
          {{ 'mdi:snowflake-alert' if this.state == 'on' else 'mdi:solar-panel' }}

      # BMS limit detection — parsed from GoodWe diagnostic status register.
      # delay_on: flag must persist 2 min before clamp activates (debounce
      #   mode-switch noise — the diag register flips between "Charge time
      #   on" / "Discharge time on" every ~7 min but BMS flags stay stable).
      # delay_off: wait 5 min after BMS lifts restriction before unclamping
      #   (prevents oscillation at the BMS edge).
      # These feed into the MPC payload to set battery_minimum/maximum_soc
      # equal to current SOC, so EMHASS doesn't plan impossible actions.
      - name: BMS Discharge Disabled
        unique_id: bms_discharge_disabled
        device_class: problem
        delay_on:
          minutes: 2
        delay_off:
          minutes: 5
        state: >-
          {{ 'BMS: Discharge disabled' in states('sensor.goodwe_diag_status') }}
        icon: >-
          {{ 'mdi:battery-off-outline' if this.state == 'on' else 'mdi:battery' }}

      - name: BMS Charge Disabled
        unique_id: bms_charge_disabled
        device_class: problem
        delay_on:
          minutes: 2
        delay_off:
          minutes: 5
        state: >-
          {{ 'BMS: Charge disabled' in states('sensor.goodwe_diag_status') }}
        icon: >-
          {{ 'mdi:battery-charging-off' if this.state == 'on' else 'mdi:battery-charging' }}

http:
  use_x_forwarded_for: true
  trusted_proxies:
    - 172.16.0.0/16
    - 172.17.0.0/16
