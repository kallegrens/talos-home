# ===========================================================================
# Tibber Integration Health
# ===========================================================================

- id: "1770642990708"
  alias: Tibber Watchdog
  description: >-
    Checks every 5 min if Tibber pulse sensor is stale (>10 min).
    Attempts one reload; if it fails, sends a persistent notification.
  triggers:
    - minutes: /5
      trigger: time_pattern
  conditions:
    - condition: template
      value_template: >-
        {% set stale_threshold_sec = 600 %}
        {% set e = states.sensor.tibber_pulse_lavendelgangen_3_power %}
        {{ e is not none and (now() - e.last_updated).total_seconds() > stale_threshold_sec }}
  actions:
    - action: homeassistant.reload_config_entry
      target:
        entity_id: sensor.tibber_pulse_lavendelgangen_3_power
      continue_on_error: true
    - delay: 00:00:30
    - condition: template
      value_template: >-
        {% set stale_threshold_sec = 600 %}
        {% set e = states.sensor.tibber_pulse_lavendelgangen_3_power %}
        {{ e is none or (now() - e.last_updated).total_seconds() > stale_threshold_sec }}
    - action: persistent_notification.create
      data:
        title: "Tibber Integration Stuck"
        message: >-
          Tibber pulse sensor stale >10 min and reload failed.
          HA restart required. Time: {{ now().isoformat() }}
        notification_id: tibber_stuck
  mode: single

- id: "1770700000005"
  alias: Tibber Cache - Populate on Startup
  description: >-
    Waits 3 min after HA start for Tibber to fully load, then fires
    a custom event that the template sensor can listen for.
  triggers:
    - trigger: homeassistant
      event: start
  actions:
    - delay: "00:03:00"
    - event: tibber_cache_refresh
  mode: single

# ===========================================================================
# EMHASS MPC Optimization
# ===========================================================================

- id: "1770700000006"
  alias: EMHASS MPC Loop
  description: >-
    Runs MPC every 4 min with dynamic prediction horizon matching
    available price data. continual_publish handles sensor updates.
    4 min chosen because it is coprime with the 15-min price slot
    boundary (GCD=1), preventing systematic alignment flip-flop,
    while giving faster SOC feedback than the previous 7-min cycle.
  triggers:
    - minutes: /4
      trigger: time_pattern
  conditions:
    - condition: template
      value_template: >-
        {{ (state_attr('sensor.nordpool_kwh_se3_sek_3_10_0', 'raw_today') | default([], true) | length > 0)
           and states('sensor.goodwe_battery_state_of_charge') | is_number }}
  actions:
    - action: rest_command.emhass_mpc_optim
  mode: single

- id: "1770700000007"
  alias: EMHASS PV Forecast Cache
  description: >-
    Caches PV weather forecast 3x daily so MPC runs reuse cached data
    instead of hitting Open-Meteo every 5 min.
  triggers:
    - at: "06:00:00"
      trigger: time
    - at: "12:00:00"
      trigger: time
    - at: "18:00:00"
      trigger: time
  actions:
    - action: rest_command.emhass_weather_cache
  mode: single

# ===========================================================================
# GoodWe Battery Control
# ===========================================================================

- id: "1770700000003"
  alias: EMHASS Battery Control
  description: >-
    Translates EMHASS p_batt_forecast into GoodWe eco-mode commands.
    Triggered by MPC publishing a new forecast OR soc target change.

    Anti-jitter: consecutive-idle ≥2 filter. The MPC re-solves every
    ~4 min and often oscillates between charge/idle on adjacent slots.
    To prevent rapid mode-cycling on the inverter, we require the
    optimizer to say "idle" at least 2 consecutive times before we
    actually transition to idle. Charge/discharge decisions are acted
    on immediately. The streak counter lives in
    input_number.emhass_idle_streak.

    Decision and rate both come from the current slot p_batt value.
    Power % is |p_batt| / 5050W, clamped to 5-100%.

    eco_mode_soc buffer is computed dynamically from the MPC interval:
    buffer = 1.3 × max SOC change per cycle (at full power). This
    gives the inverter headroom to keep acting through the cycle
    without hitting the SOC limit before the next re-solve.

    Grid export limit is set to 0W on discharge to prevent battery
    energy spilling to grid at a loss. On charge/idle the limit is
    lifted so solar export is not blocked.
  triggers:
    - trigger: state
      entity_id: sensor.p_batt_forecast
    - trigger: state
      entity_id: sensor.soc_batt_forecast
  conditions:
    - condition: template
      value_template: >-
        {{ states('sensor.p_batt_forecast') not in ['unknown', 'unavailable']
           and states('sensor.soc_batt_forecast') not in ['unknown', 'unavailable'] }}
  actions:
    - variables:
        # --- Hardware constants ---
        inverter_rated_w: 10000
        batt_max_w: 5050
        batt_capacity_wh: 14200
        grid_export_limit_w: 10000
        grid_export_discharge_w: 0
        min_power_pct: 5
        min_soc_pct: 5
        max_soc_pct: 100
        # GoodWe device_id for goodwe.set_parameter service
        goodwe_device_id: "ea2d8925fee08c1321c7f038b61e111e"
        # Default battery charge/discharge current (A)
        default_charge_current: 25
        default_discharge_current: 25
        # --- Tuning parameters ---
        mpc_interval_min: 4
        deadband_w: 200
        idle_streak_required: 2
        soc_buffer_safety_factor: 1.3
        soc_buffer_min_pct: 2
        default_soc: 50
        # --- Sensor readings ---
        p_batt: "{{ states('sensor.p_batt_forecast') | float(0) }}"
        target_soc: "{{ states('sensor.soc_batt_forecast') | float(default_soc) }}"
        # --- Derived values ---
        soc_buffer: >-
          {{ [((batt_max_w * mpc_interval_min / 60 / batt_capacity_wh * 100) * soc_buffer_safety_factor) | round(0) | int, soc_buffer_min_pct] | max }}
        # Max eco_mode_power % the battery can physically deliver/absorb
        max_power_pct: "{{ (batt_max_w / inverter_rated_w * 100) | round(0) | int }}"
        # Power % of inverter rated power, clamped [min_power_pct .. max_power_pct]
        # GoodWe firmware interprets eco_mode_power as % of inverter_rated_w (10kW),
        # NOT battery max. E.g. 20% = 2000W cap on charge/discharge rate.
        # Upper clamp = batt_max_w/inverter_rated_w ≈ 50% (battery can't exceed 5050W).
        power_pct: >-
          {{ [[(( p_batt | float | abs) / inverter_rated_w * 100) | round(0) | int, min_power_pct] | max, max_power_pct | int] | min }}
        # Decision from current slot
        raw_decision: >-
          {% if p_batt | float < -deadband_w %}charge
          {% elif p_batt | float > deadband_w %}discharge
          {% else %}idle{% endif %}
        # Read and update idle streak
        prev_streak: "{{ states('input_number.emhass_idle_streak') | int(0) }}"
        new_streak: >-
          {% if raw_decision == 'idle' %}{{ prev_streak + 1 }}
          {% else %}0{% endif %}
        # Final decision: suppress idle unless streak reaches threshold
        decision: >-
          {% if raw_decision == 'idle' and new_streak | int < idle_streak_required %}hold
          {% else %}{{ raw_decision }}{% endif %}
    # Always persist the streak counter
    - action: input_number.set_value
      target:
        entity_id: input_number.emhass_idle_streak
      data:
        value: "{{ new_streak }}"
    - choose:
        # --- CHARGE ---
        # eco_charge: grid+PV → battery at controlled rate.
        # Order matters: set eco mode FIRST, then restore currents
        # AFTER a delay. The work_mode register write inside
        # set_operation_mode can reset battery current registers,
        # so they must be written last to stick.
        - conditions:
            - condition: template
              value_template: "{{ decision == 'charge' }}"
          sequence:
            - action: number.set_value
              target:
                entity_id: number.goodwe_grid_export_limit
              data:
                value: "{{ grid_export_limit_w }}"
            - action: number.set_value
              target:
                entity_id: number.goodwe_eco_mode_power
              data:
                value: "{{ power_pct }}"
            - action: number.set_value
              target:
                entity_id: number.goodwe_eco_mode_soc
              data:
                value: "{{ [target_soc | round(0) | int + soc_buffer | int, max_soc_pct] | min }}"
            - action: select.select_option
              target:
                entity_id: select.goodwe_inverter_operation_mode
              data:
                option: eco_charge
            - delay:
                seconds: 2
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_charge_current
                value: "{{ default_charge_current }}"
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_discharge_current
                value: "{{ default_discharge_current }}"

        # --- DISCHARGE ---
        # eco_discharge: battery → house at controlled rate.
        # grid_export_limit=0 prevents battery→grid spill.
        # Order matters: set eco mode FIRST, then restore currents
        # AFTER a delay. The work_mode register write inside
        # set_operation_mode can reset battery current registers
        # (observed: idle→discharge stuck at 0A without this).
        - conditions:
            - condition: template
              value_template: "{{ decision == 'discharge' }}"
          sequence:
            - action: switch.turn_on
              target:
                entity_id: switch.goodwe_grid_export_limit_switch
            - action: number.set_value
              target:
                entity_id: number.goodwe_grid_export_limit
              data:
                value: "{{ grid_export_discharge_w }}"
            - action: number.set_value
              target:
                entity_id: number.goodwe_eco_mode_power
              data:
                value: "{{ power_pct }}"
            - action: number.set_value
              target:
                entity_id: number.goodwe_eco_mode_soc
              data:
                value: "{{ [target_soc | round(0) | int - soc_buffer | int, min_soc_pct] | max }}"
            - action: select.select_option
              target:
                entity_id: select.goodwe_inverter_operation_mode
              data:
                option: eco_discharge
            - delay:
                seconds: 2
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_charge_current
                value: "{{ default_charge_current }}"
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_discharge_current
                value: "{{ default_discharge_current }}"

        # --- IDLE (streak reached) ---
        # general mode + battery_discharge_current=0:
        # - PV powers house first (self-consumption)
        # - PV surplus charges battery
        # - Battery CANNOT discharge (discharge_current=0)
        # - Export only when battery full + excess PV
        # - No grid→battery charge (general mode never does this)
        # Order matters: set_operation_mode(general) calls
        # _clear_battery_mode_param(), so set discharge_current
        # AFTER the mode change to ensure it sticks.
        - conditions:
            - condition: template
              value_template: "{{ decision == 'idle' }}"
          sequence:
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_charge_current
                value: "{{ default_charge_current }}"
            - action: number.set_value
              target:
                entity_id: number.goodwe_grid_export_limit
              data:
                value: "{{ grid_export_limit_w }}"
            - action: select.select_option
              target:
                entity_id: select.goodwe_inverter_operation_mode
              data:
                option: general
            - delay:
                seconds: 2
            - action: goodwe.set_parameter
              data:
                device_id: "{{ goodwe_device_id }}"
                parameter: battery_discharge_current
                value: 0

      # --- HOLD: idle suppressed, keep current mode ---
      # The optimizer said idle but streak < threshold.
      # Do nothing — let the previous charge/discharge continue.
      default: []
  mode: restart

# ===========================================================================
# Failsafe
# ===========================================================================

- id: "1770700000004"
  alias: EMHASS Failsafe
  description: >-
    If p_batt_forecast is stale >20 min, switch to general mode
    with discharge blocked (battery_discharge_current=0). Battery
    holds SOC, PV charges it, house draws from grid. Checks every
    7 min. Prevents uncontrolled discharge if EMHASS stops.
  triggers:
    - minutes: /7
      trigger: time_pattern
  conditions:
    - condition: template
      value_template: >-
        {% set stale_threshold_sec = 1200 %}
        {% set sensor = states.sensor.p_batt_forecast %}
        {{ sensor is none or
           sensor.state in ['unknown', 'unavailable'] or
           (now() - sensor.last_updated).total_seconds() > stale_threshold_sec }}
  actions:
    - variables:
        goodwe_device_id: "ea2d8925fee08c1321c7f038b61e111e"
        default_charge_current: 25
        grid_export_limit_w: 10000
    - action: goodwe.set_parameter
      data:
        device_id: "{{ goodwe_device_id }}"
        parameter: battery_charge_current
        value: "{{ default_charge_current }}"
    - action: number.set_value
      target:
        entity_id: number.goodwe_grid_export_limit
      data:
        value: "{{ grid_export_limit_w }}"
    - action: select.select_option
      target:
        entity_id: select.goodwe_inverter_operation_mode
      data:
        option: general
    - delay:
        seconds: 2
    - action: goodwe.set_parameter
      data:
        device_id: "{{ goodwe_device_id }}"
        parameter: battery_discharge_current
        value: 0
    - action: persistent_notification.create
      data:
        title: "EMHASS Failsafe Triggered"
        message: >-
          p_batt_forecast stale >20 min. General mode +
          discharge blocked. Battery holds SOC, PV charges.
  mode: single

# ===========================================================================
# Snow Detection  (latching design)
#   binary_sensor.solar_snow_detected  = real-time detector (daytime only)
#   input_boolean.solar_panels_snow_covered = latching flag checked by MPC
# ===========================================================================

- id: "1770700000008"
  alias: Solar Snow - Latch ON
  description: >-
    When the detector fires (forecast > 100W, actual < 5%), latch the
    input_boolean ON. Requires the boolean to have been OFF for at
    least 1 hour, preventing re-latch after manual override or
    auto-clear.
  triggers:
    - trigger: state
      entity_id: binary_sensor.solar_snow_detected
      to: "on"
  conditions:
    - condition: state
      entity_id: input_boolean.solar_panels_snow_covered
      state: "off"
      for: "01:00:00" # relatch_cooldown: min off-time before re-latching
  actions:
    - action: input_boolean.turn_on
      target:
        entity_id: input_boolean.solar_panels_snow_covered
    - action: persistent_notification.create
      data:
        title: "☃️ Snow Mode Active"
        message: >-
          Auto-detected snow on panels at {{ now().strftime('%H:%M') }}.
          Forecast={{ states('sensor.p_pv_forecast') }}W,
          actual={{ states('sensor.goodwe_pv_power') }}W.
          MPC will zero PV forecast until panels are clear.
        notification_id: solar_snow
  mode: single

- id: "1770700000009"
  alias: Solar Snow - Auto Clear
  description: >-
    Clears snow mode only when there is strong evidence panels are
    truly clear: actual PV > 50% of forecast AND > 200W absolute,
    sustained for 30 min, during midday (09–15) when sun angle gives
    a reliable signal. Prevents false clears from light leaking
    around snow edges or brief cloud gaps.
  triggers:
    - trigger: template
      value_template: >-
        {% set snow_clear_min_w = 200 %}
        {% set snow_clear_ratio = 0.50 %}
        {% set midday_start_hour = 9 %}
        {% set midday_end_hour = 15 %}
        {% set forecast = states('sensor.p_pv_forecast') | float(0) %}
        {% set actual = states('sensor.goodwe_pv_power') | float(0) %}
        {% set midday = midday_start_hour <= now().hour < midday_end_hour %}
        {{ midday and forecast > snow_clear_min_w and actual > snow_clear_min_w
           and actual > forecast * snow_clear_ratio }}
      for: "00:30:00" # snow_clear_sustain_duration
  conditions:
    - condition: state
      entity_id: input_boolean.solar_panels_snow_covered
      state: "on"
  actions:
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.solar_panels_snow_covered
    - action: persistent_notification.create
      data:
        title: "☀️ Snow Mode Cleared"
        message: >-
          Panels confirmed clear at {{ now().strftime('%H:%M') }}
          ({{ states('sensor.goodwe_pv_power') }}W actual vs
          {{ states('sensor.p_pv_forecast') }}W forecast, sustained 30 min).
          Normal PV forecast restored.
        notification_id: solar_snow
  mode: single
